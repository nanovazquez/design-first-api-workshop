# Exercise 3: Using a Server Stub as a Backend

In this exercise, you will learn how to leverage the capabilities of an autogenerated server stub. You will start with small introduction to what a server stub is and why is it important. Then, you will move onto a hands on section and generate the server stub of your OAS Document, investigate the different benefits that are brought out of the box, and finally connect it to the UI app.

Let's begin then!

## What is a Server Stub

A Server Stub is nothing more than an implementation of your API. It's autogenerated code that takes what you've specified throughout your OAS Document and makes it available to be consumed as a small server by stubbing methods (You will analyze in a coming section how are these methods stubbed)

You might be thinking why going through the trouble of autogenerating code of your API is useful. It's understandable. So here are two reasons that might convince you:

- First of all, you will be able to have a working server without the need of having to implement any kind of logic. This will help you in parallelizing the work being done between UI and Backend.

- Second of all, it is super simple!

## Converting your OAS Document into an Autogenerated API Implementation

So, how can you do this? How can you go from an OAS Document to a Server Stub and use it?

### Generating the Server Stub

First you will generate the Server Stub by following these steps:

1. Open the API page in SwaggerHub.

2. Look for the Export menu on the upper-right section, click it, select *Server Stub* and then the **nodejs-server** option.

![Export Server Stub](./assets/export-server-stub.png)

3. Once it finishes downloading, unzip it.

```
$ unzip nodejs-server-server-generated.zip -d nodejs-server-server-generated
Archive:  nodejs-server-server-generated.zip
  inflating: nodejs-server-server-generated/service/DefaultService.js
  inflating: nodejs-server-server-generated/utils/writer.js
  inflating: nodejs-server-server-generated/controllers/Default.js
  inflating: nodejs-server-server-generated/README.md
  inflating: nodejs-server-server-generated/index.js
  inflating: nodejs-server-server-generated/api/swagger.yaml
  inflating: nodejs-server-server-generated/.swagger-codegen-ignore
  inflating: nodejs-server-server-generated/.swagger-codegen/VERSION
  inflating: nodejs-server-server-generated/package.json
```

Great! You now have an implementation of your API waiting to be configured and run. For this, you just need to run the command `npm start` inside the decompressed folder.

```
$ npm start

> nodeconf-api@1.0.0 prestart /Users/sebastianrodriguez/Documents/ot/projects/design-first-nodeconf/nodejs-server-server-generated
> npm install

npm WARN deprecated formidable@1.0.17: Old versions of Formidable are not compatible with the current Node.js; Upgrade to 1.2.0 or later
npm notice created a lockfile as package-lock.json. You should commit this file.
added 147 packages in 7.812s

> nodeconf-api@1.0.0 start /Users/sebastianrodriguez/Documents/ot/projects/design-first-nodeconf/nodejs-server-server-generated
> node index.js

Your server is listening on port 8080 (http://localhost:8080)
Swagger-ui is available on http://localhost:8080/docs
```

What just happenned?

- A _prestart_ script was run, installing all the missing dependencies (`"prestart": "npm install"`)

- The _start_ script was run and started a localhost server (`"Your server is listening on port 8080 (http://localhost:8080)"`)

- Finally, it stated that there is a `"Swagger-ui available"`. You'll see what this is in a bit.

And that's it, you have a Server Stub of your OAS Document up & running, ready to be consumed. Let's try it out!

### Testing the Server Stub

In order to test if it's running as expected, you can hit any of the endpoints that were written down on the OAS Document, like retrieving all the speakers.

Going back to the OAS Document, you will see that:

- The API has a _basePath_ at the bottom of the form: **/{owner-name}/{api-name}/{api-version}**

- To retrieve the speakers, you need to do a **GET** to **/editions/{editionId}/speakers**

Combining these two things, plus the localhost baseUri, you get the following endpoint:

`http://localhost:8080/{owner-name}/{api-name}/{api-version}/editions/{editionId}/speakers`

Replace _editionId_ for a valid integer number (like it was defined in the parameter schema) and consume the endpoint with your preferred way. For example:

```
$ curl http://localhost:8080/nodeconf18-api-spec/nodeconf-api/1.0.0/editions/2018/speakers
```

And you will see a response
```
[
  {
    "twitterAccount": "@john-doe",
    "imageUrl": "http://some.image.com/image.png",
    "name": "John Doe",
    "description": "Node JS Developer",
    "id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
    "githubAccount": "@i-am-a-developer"
  },
  {
    "twitterAccount": "@john-doe",
    "imageUrl": "http://some.image.com/image.png",
    "name": "John Doe",
    "description": "Node JS Developer",
    "id": "d290f1ee-6c54-4b01-90e6-d701748f0851",
    "githubAccount": "@i-am-a-developer"
  }
]
```

It works!

## Investigating under the hood

So, when testing the Server Stub, you saw a pretty familiar response, right? Well, yes!

The server is using all the information you placed on your OAS Document to return a proper response. Let's do a quick analysis how this is being done.

Go to the Server Stub folder and open the `DefaultService.js` file contained inside the `service` directory.

You will notice that this service is exporting all of the different endpoints your OAS Document defined as functions. For example:

```
exports.editionsEditionIdActivitiesGET = function(editionId,searchString)
```

And all functions are returning with harcoded values. They are the ones you placed as examples in the responses section of each endpoint.

This information is fed to the `Default.js` controller (located in the `controllers` directory) that, same as the service, exports a function for each endpoint.

This controller is finally used in `index.js`. This is the app main entry file. You will see that it does a couple of things.

First, it initializes a middleware, with the spec you wrote, that will be in charge of:

- Interpreting Swagger resources and attach metadata to request

- Validate all incoming requests and see if they are valid against the spec (endpoints exist, schema is valid, etc)

- Route requests to the appropriate controller (In this case, to the `Default.js` controller)

- Serve the **Swagger-UI**

> **Note**: All these out of the box tools are provided by the module swagger-tools. You can read more [here](https://www.npmjs.com/package/swagger-tools)

Finally, starts a simple http server.

That's all it needs to generate and create a Stub Server of your OAS Document. Pretty neat, isn't it?

## Additional Benefits

- Autogenerated docs
show how to see them

- Leaving your app ready to connect to the backend

## Connecting the dots
Connecting frontend to server stub

## Bonus track
- Have it versioned with Git
- Upload it with Heroku/Now/etc
